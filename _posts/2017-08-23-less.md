---
layout:     post
title:      "less 笔记"
subtitle:   "学习less语法"
date:       2017-08-28
author:     "handsameliu"
header-img: "img/post-bg-less-big.jpg"
tags:
    - Less
---

CSS（层叠样式表）是一门历史悠久的标记性语言，同 HTML 一道，被广泛应用于万维网（World Wide Web）中。HTML 主要负责文档结构的定义，CSS 负责文档表现形式或样式的定义。

<!-- more -->

作为一门标记性语言，CSS 的语法相对简单，对使用者的要求较低，但同时也带来一些问题：CSS 需要书写大量看似没有逻辑的代码，不方便维护及扩展，不利于复用，尤其对于非前端开发工程师来讲，往往会因为缺少 CSS 编写经验而很难写出组织良好且易于维护的 CSS 代码，造成这些困难的很大原因源于 CSS 是一门非程序式语言，没有变量、函数、SCOPE（作用域）等概念。LESS 为 Web 开发者带来了福音，它在 CSS 的语法基础之上，引入了变量，Mixin（混入），运算以及函数等功能，大大简化了 CSS 的编写，并且降低了 CSS 的维护成本，就像它的名称所说的那样，LESS 可以让我们用更少的代码做更多的事情。

> 相比sass来说，less编译的依赖不多。

## 在客户端使用

和引入css一样直接使用style标签引入，但是rel的属性要设置为"`stylesheet/less`" 。
在引入less文件后一定要引入`less.js`，否则可能会编译解析出错。

```html
  <link rel="stylesheet/less" type="text/css" href="styles.less">
```

## 在服务器端使用

less在服务器端的使用主要是借助于less的编译器，将less源文件编译生成最终的css文件。
目前常用且简单的方式是利用node的包管理器(npm)安装less。

    $ npm install less

如果你想要安装稳定版的less，如下：

    $ npm install less@latest

在项目开发初期，我们无论采用客户端还是服务器端的用法，我们都需要想办法将我们要用到的css或less文件引入到我们的html页面或是桥接文件中，less提供了一个我们很熟悉的功能`Importing`。我们可以通过这个关键字引入我们需要的 .less 或 .css 文件。 如：

@import “variables.less”;

.less 文件也可以省略后缀名，像这样：@import “variables”;

引入css同less文件一样，只是.css 后缀名不能省略。

### 使用编译生成的静态 CSS 文件

我们可以通过less的编译器，将less文件编译成为css文件，在html文章中引入使用。这里要强调的一点，less是完全兼容css语法的，也就是说，我们可以将标准的css文件直接改成 .less 格式，less编译器可以完全识别。

### 使用

当我们安装了less，就可以在node中这样调用编译器：

```javascript
var less = require('less');
less.render('.class { width: 1 + 1 }', function (e, css) {
    console.log(css);
});
```

输出的结果是：

```less
.class {
    width: 2;
}
```

当然也可以手动调用解析器和编译器：

```javascript
var parser = new(less.Parser);
parser.parse('.class { width: 1 + 1 }', function (err, tree) {
    if (err) { return console.error(err) }
    console.log(tree.toCSS());
});
```

### 配置

你可以向解析器传递参数

```javascript
var parser = new(less.Parser)({
    paths: ['.', './lib'], // Specify search paths for @import directives
    filename: 'style.less' // Specify a filename, for better error messages
});

parser.parse('.class { width: 1 + 1 }', function (e, tree) {
    tree.toCSS({ compress: true }); // Minify CSS output
});
```

### 在命令行下使用

你可以在终端调用 LESS 解析器:

    $ lessc styles.less

上面的命令会将编译后的 CSS 传递给 stdout, 你可以将它保存到一个文件中:

    $ lessc styles.less > styles.css

如何你想将编译后的 CSS 压缩掉，那么加一个 -x 参数就可以了.

## 变量

顾名思义，变量可以让我们定义一系列的值，以达到复用的效果，所以等我们修改代码样式的时候只需要修改这一个变量就可以了。

> 请注意 LESS 中的变量为完全的 ‘常量’ ，所以只能定义一次

```less
/* LESS */
@color: #4D926F;
#header {
  color: @color;
}
h2 {
  color: @color;
}

/* 生成的 CSS */
#header {
  color: #4D926F;
}
h2 {
  color: #4D926F;
}
```

## 混合

就是讲两个class混合到一起，从而使两个class具有继承关系，他们还可以像函数一样带有`参数`的调用。
例如classA被classB引用，那么classB就继承并具有了classA的所有属性。

> 任何 CSS class, id 或者 元素 属性集都可以以同样的方式引入

```less
/* LESS */
.rounded-corners (@radius: 5px) {
  border-radius: @radius;
  -webkit-border-radius: @radius;
  -moz-border-radius: @radius;
}
#header {
  .rounded-corners;
}
#footer {
  .rounded-corners(10px); /* 带参了，所以默认值5px会被替换为10px*/
}

/* 生成的 CSS */
/* 不带参的函数 */
#header {
  border-radius: 5px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
}
/* 带参的函数 */
#footer {
  border-radius: 10px;
  -webkit-border-radius: 10px;
  -moz-border-radius: 10px;
}
```

你也可以定义不带参数属性集合,如果你想隐藏这个属性集合，不让它暴露到CSS中去，但是你还想在其他的属性集合中引用，你会发现这个方法非常的好用:

```less
/* less */
.wrap () {
  text-wrap: wrap;
  white-space: pre-wrap;
  white-space: -moz-pre-wrap;
  word-wrap: break-word;
}
pre { .wrap }

/* css */
pre {
  text-wrap: wrap;
  white-space: pre-wrap;
  white-space: -moz-pre-wrap;
  word-wrap: break-word;
}
```

### @arguments 变量

@arguments包含了所有传递进来的参数. 如果你不想单独处理每一个参数的话就可以像这样写:

```less
/* less */
.box-shadow (@x: 0, @y: 0, @blur: 1px, @color: #000) {
  box-shadow: @arguments;
  -moz-box-shadow: @arguments;
  -webkit-box-shadow: @arguments;
}
.box-shadow(2px, 5px);

/* css */
box-shadow: 2px 5px 1px #000;
-moz-box-shadow: 2px 5px 1px #000;
-webkit-box-shadow: 2px 5px 1px #000;

```

## 模式匹配和导引表达式

有些情况下，我们想根据传入的参数来改变混合的默认呈现，比如下面这个例子：

```less
.mixin (@s, @color) { ... }

.class {
  .mixin(@switch, #888);
}
```

如果想让.mixin根据不同的@switch值而表现各异，如下这般设置：

```less
.mixin (dark, @color) {
  color: darken(@color, 10%);
}
.mixin (light, @color) {
  color: lighten(@color, 10%);
}
.mixin (@_, @color) { /* @_通配，都不论第一个参数是什么都会包括 */
  display: block;
}
```

```less
/* less */
@switch: light;

.class {
  .mixin(@switch, #888);
}

/* css */
.class {
  color: #a2a2a2;
  display: block;
}
```

如上，`.mixin`就会得到传入颜色的浅色。如果`@switch`设为dark，就会得到深色。

具体实现如下：

> 第一个混合定义并未被匹配，因为它只接受dark做为首参

> 第二个混合定义被成功匹配，因为它只接受light

> 第三个混合定义被成功匹配，因为它接受任意值

只有被匹配的混合才会被使用。变量可以匹配任意的传入值，而变量以外的固定值就仅仅匹配与其相等的传入值。

我们也可以匹配多个参数：

```less
.mixin (@a) {
  color: @a;
}
.mixin (@a, @b) {
  color: fade(@a, @b);
}
```

如果我们现在调用，.mixin使用带有一个参数，那么我们将使用的是只有一个参数的.mixin(@a)。如果传递了两个参数，那么将使用带有两个参数的.mixin(@a,@b)。

### 引导

当我们想根据表达式进行匹配，而非根据值和参数匹配时，导引就显得非常有用。如果你对函数式编程非常熟悉，那么你很可能已经使用过导引。

为了尽可能地保留CSS的可声明性，LESS通过导引混合而非if/else语句来实现条件判断，因为前者已在`@media query`特性中被定义。

以此例做为开始：

```less
.mixin (@a) when (lightness(@a) >= 50%) {
  background-color: black;
}
.mixin (@a) when (lightness(@a) < 50%) {
  background-color: white;
}
.mixin (@a) {
  color: @a;
}
```

`when`关键字用以定义一个导引序列(此例只有一个导引)。接下来我们运行下列代码：

```less
/* less */
.class1 { .mixin(#ddd) }
.class2 { .mixin(#555) }

/* css */
.class1 {
  background-color: black;
  color: #ddd;
}
.class2 {
  background-color: white;
  color: #555;
}
```

导引中可用的全部比较运算有： `> >= = =< <`。此外，关键字`true`只表示`布尔真`值，下面两个混合是相同的：

```less
.truth (@a) when (@a) { ... }
.truth (@a) when (@a = true) { ... }
```

除去`关键字true以外的值`都被视示`布尔假`：

```less
.class {
    .truth(40); // 不符合上述定义中的任何一种。 因为值为false
}
```

导引序列使用逗号‘,’—分割，当且仅当所有条件都符合时，才会被视为匹配成功。

```less
.mixin (@a) when (@a > 10), (@a < -10) { ... }
```

导引可以无参数，也可以对参数进行比较运算：

```less
@media: mobile;

.mixin (@a) when (@media = mobile) { ... }
.mixin (@a) when (@media = desktop) { ... }

.max (@a, @b) when (@a > @b) { width: @a }
.max (@a, @b) when (@a < @b) { width: @b }
```

如果想基于值的类型进行匹配，我们就可以使用is*函式：

```less
.mixin (@a, @b: 0) when (isnumber(@b)) { ... }
.mixin (@a, @b: black) when (iscolor(@b)) { ... }
```

下面就是常见的检测函式：

```
iscolor
isnumber
isstring
iskeyword
isurl
```

如果你想判断一个值是纯数字，还是某个单位量，可以使用下列函式：

```less
ispixel  //px 
ispercentage   //百分比
isem  // em
```

最后再补充一点，在导引序列中可以使用`and`关键字实现`与`条件：

```less
.mixin (@a) when (isnumber(@a)) and (@a > 0) { ... }
```

使用`not`关键字实现`或`条件

```less
.mixin (@b) when not (@b > 0) { ... }
```

## 嵌套

如同混合，目的同样是让不同的class合并为一个，这样可以从很大程度上减少代码量，并且代码看起来更清晰。而且会感觉跟DOM结构格式有点像。

```less
/* LESS */
#header {
  h1 {
    font-size: 26px;
    font-weight: bold;
  }
  p { font-size: 12px;
    a { text-decoration: none;
      &:hover { border-width: 1px }
    }
  }
}

/* 生成的 CSS */
#header h1 {
  font-size: 26px;
  font-weight: bold;
}
#header p {
  font-size: 12px;
}
#header p a {
  text-decoration: none;
}
#header p a:hover {
  border-width: 1px;
}
```

注意 & 符号的使用—如果你想写串联选择器，而不是写后代选择器，就可以用到&了. 这点对伪类尤其有用如 :hover 和 :focus.

```less
/* less */
.bordered {
  &.float {
    float: left; 
  }
  .top {
    margin: 5px; 
  }
}

/* css */
.bordered.float {
  float: left;  
}
.bordered .top {
  margin: 5px;
}
```


## 函数&运算

函数提供了加减乘除操作,可以做属性和颜色的操作。这样就可以实现属性间的复杂关系。LESS的函数和js中是一一对应的，如果你想还能操作属性值。

```less
/* LESS */

@the-border: 1px;
@base-color: #111;
@red:        #842210;

#header {
  color: @base-color * 3;
  border-left: @the-border;
  border-right: @the-border * 2;
}
#footer { 
  color: @base-color + #003300;
  border-color: desaturate(@red, 10%);/*饱和度*/
}

/* 生成的 CSS */
#header {
  color: #333;
  border-left: 1px;
  border-right: 2px;
}
#footer { 
  color: #114411;
  border-color: #7d2717;
}

```

例如：

```less
@base: 5%;
@filler: @base * 2;
@other: @base + @filler;

color: #888 / 4;
background-color: @base-color + #111;
height: 100% / 2 + @filler;
```

LESS 的运算已经超出了我们的期望，它能够分辨出颜色和单位。如果像下面这样单位运算的话:

```less
@var: 1px + 5;
```

LESS 会输出 6px.

括号也同样允许使用:

```css
width: (@var + 5) * 2;
```

并且可以在复合属性中进行运算:

```
border: (@width * 2) solid black;
```

### Color 函数

LESS 提供了一系列的颜色运算函数. 颜色会先被转化成 HSL 色彩空间, 然后在通道级别操作:

```less
lighten(@color, 10%);     // 返回一个比输入颜色浅10%的颜色
darken(@color, 10%);      // 返回一个比输入颜色深10%的颜色

saturate(@color, 10%);    // 返回的颜色比输入颜色多10%
desaturate(@color, 10%);  // 返回的颜色比输入颜色少10%

fadein(@color, 10%);      // 返回的颜色比输入的颜色透明10%
fadeout(@color, 10%);     // 返回的颜色比输入的颜色透明10%
fade(@color, 50%);        // 返回的颜色透明度为50%

spin(@color, 10);         // 返回的颜色比输入的颜色大10度
spin(@color, -10);        // 返回的颜色比输入的颜色小10度

mix(@color1, @color2);    // 返回的颜色是color1与color2的混合
```

还可以提取颜色信息:

```less
hue(@color);        // 返回输入颜色的色调
saturation(@color); // 返回输入颜色的饱和度
lightness(@color);  // 返回输入颜色的亮度
```

如果你想在一种颜色的通道上创建另一种颜色，这些函数就显得那么的好用，例如:

```less
@new: hsl(hue(@old), 45%, 90%);
```

@new 将会保持 @old的`色调`, 但是具有不同的`饱和度`和`亮度`.

### Math 函数

LESS提供了一组方便的数学函数，你可以使用它们处理一些数字类型的值:

```less
round(1.67); // returns `2`  四舍五入
ceil(2.4);   // returns `3`  向上取舍，返回大于或者等于指定表达式的最小整数
floor(2.6);  // returns `2`  向下取舍，返回小于或者等于指定表达式的最小整数
```

如果你想将一个值转化为百分比，你可以使用`percentage` 函数:

```less
percentage(0.5); // returns `50%`
```

## 命名空间

有时候，你可能为了更好组织CSS或者单纯是为了更好的封装，将一些变量或者混合模块打包起来, 你可以像下面这样在#bundle中定义一些属性集之后可以重复使用:

```less
#bundle {
  .button () {
    display: block;
    border: 1px solid black;
    background-color: grey;
    &:hover { background-color: white }
  }
  .tab { ... }
  .citation { ... }
}
```

你只需要在 #header a中像这样引入 .button:

```less
#header a {
  color: orange;
  #bundle > .button;
}
```

## 作用域

LESS 中的作用域跟其他编程语言非常类似，首先会从`本地查找变量`或者`混合模块`，如果没找到的话会去`父级作用域`中查找，直到找到为止.

```less
@var: red;
#page {
  @var: white;
  #header {
    color: @var; // white
  }
}
#footer {
  color: @var; // red  
}
```

## 注释

CSS 形式的注释在 LESS 中是依然保留的:

```less
/* Hello, I'm a CSS-style comment */
.class { color: black }
```

LESS 同样也支持双斜线的注释, 但是编译成 CSS 的时候自动过滤掉:

```less
// Hi, I'm a silent comment, I won't show up in your CSS
.class { color: white }
```

## Importing

上面已经讲解过`importing`引入了。这里在说一下，你可以在main文件中通过下面的形势引入 .less 文件, .less 后缀可带可不带:

```less
@import "lib.less";
@import "lib";
```

如果你想导入一个CSS文件而且不想LESS对它进行处理，只需要使用`.css后缀`就可以:

```less
@import "lib.css";
```

这样LESS就会跳过它不去处理它.

## 字符串插值

变量可以用类似ruby和php的方式嵌入到字符串中，像`@{name}`这样的结构:

```less
@base-url: "http://assets.fnord.com";
background-image: url("@{base-url}/images/bg.png");
```

## 避免编译

有时候我们需要输出一些不正确的CSS语法或者使用一些 LESS不认识的专有语法.

要输出这样的值我们可以在字符串前加上一个 ~, 例如:

```less
.class {
    filter: ~"ms:alwaysHasItsOwnSyntax.For.Stuff()";
}
```

我们可以将要避免编译的值用 “”包含起来，输出结果为:

```less
.class {
    filter: ms:alwaysHasItsOwnSyntax.For.Stuff();
}
```

## JavaScript 表达式

JavaScript 表达式也可以在`.less`文件中使用. 可以通过`反引号`的方式使用:

```less
/* less */
@var: `"hello".toUpperCase() + '!'`;

/* css 输出*/
@var: "HELLO!";
```

注意你也可以同时使用字符串插值和避免编译:

```less
/* less */
@str: "hello";
@var: ~`"@{str}".toUpperCase() + '!'`;

/* css 输出 */
@var: HELLO!;
```

它也可以访问`JavaScript环境`:

```less
@height: `document.body.clientHeight`;
```

如果你想将一个JavaScript`字符串`解析成`16进制`的颜色值, 你可以使用 color 函数:

```less
@color: color(`window.colors.baseColor`);
@darkcolor: darken(@color, 10%);
```


> 参考：https://www.ibm.com/developerworks/cn/web/1207_zhaoch_lesscss/

> 参考：http://www.bootcss.com/p/lesscss/

